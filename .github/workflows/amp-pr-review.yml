name: AMP AI Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - develop
      - main

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  JAVA_VERSION: '11'
  NODE_VERSION: '20'

jobs:
  amp-automated-review:
    name: AMP Automated Code Review
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Get changed files
        id: changed-files
        run: |
          JAVA_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep -E '\.java$' | grep -v '/test/' | tr '\n' ' ')
          TEST_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep -E 'Test\.java$' | tr '\n' ' ')
          ALL_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | tr '\n' ' ')
          
          echo "java_files=$JAVA_FILES" >> $GITHUB_OUTPUT
          echo "test_files=$TEST_FILES" >> $GITHUB_OUTPUT
          echo "all_files=$ALL_FILES" >> $GITHUB_OUTPUT
          echo "java_count=$(echo $JAVA_FILES | wc -w)" >> $GITHUB_OUTPUT
          echo "test_count=$(echo $TEST_FILES | wc -w)" >> $GITHUB_OUTPUT

      - name: Build and analyze
        id: build-analyze
        run: |
          mvn clean compile -B -q 2>&1 | tee build-log.txt
          BUILD_STATUS=$?
          
          mvn test -B 2>&1 | tee test-log.txt || true
          
          echo "build_status=$BUILD_STATUS" >> $GITHUB_OUTPUT

      - name: Install Sourcegraph AMP SDK
        run: npm install @sourcegraph/amp-sdk

      - name: Run AMP Code Review
        if: steps.changed-files.outputs.java_files != ''
        env:
          AMP_API_KEY: ${{ secrets.AMP_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CHANGED_FILES: ${{ steps.changed-files.outputs.java_files }}
          TEST_FILES: ${{ steps.changed-files.outputs.test_files }}
        run: |
          cat << 'EOF' > amp-review.mjs
          import { execute } from '@sourcegraph/amp-sdk';
          import { readFileSync, existsSync, writeFileSync } from 'fs';
          
          const changedFiles = process.env.CHANGED_FILES?.trim().split(' ').filter(Boolean) || [];
          const testFiles = process.env.TEST_FILES?.trim().split(' ').filter(Boolean) || [];
          
          if (changedFiles.length === 0) {
            console.log('No Java files changed.');
            writeFileSync('review-comments.json', JSON.stringify({ summary: '', comments: [] }));
            process.exit(0);
          }
          
          // Read file contents for context with line numbers
          let fileContents = '';
          for (const file of changedFiles.slice(0, 5)) {
            if (existsSync(file)) {
              try {
                const content = readFileSync(file, 'utf8');
                const lines = content.split('\n').map((line, i) => `${i + 1}: ${line}`).join('\n');
                fileContents += `\n\n--- ${file} ---\n${lines.substring(0, 4000)}`;
              } catch (e) {
                console.error(`Could not read ${file}`);
              }
            }
          }
          
          const prompt = `
          You are reviewing a Pull Request for a Java/Spring Boot application (Punchout Platform).
          
          Review the following changed files and provide BOTH:
          
          1. A summary review with overall assessment
          2. Specific inline comments with EXACT file paths and line numbers
          
          Changed files: ${changedFiles.join(', ')}
          Test files changed: ${testFiles.length > 0 ? testFiles.join(', ') : 'None'}
          
          ${fileContents}
          
          IMPORTANT: Return your review as a JSON object with this EXACT structure:
          {
            "summary": "Your overall review summary in markdown format",
            "decision": "APPROVE" or "REQUEST_CHANGES" or "COMMENT",
            "comments": [
              {
                "path": "exact/file/path.java",
                "line": 42,
                "body": "Your comment about this specific line"
              }
            ]
          }
          
          For each comment:
          - "path" must match exactly one of the changed files
          - "line" must be a valid line number from the file
          - "body" should include emoji: ‚ö†Ô∏è for warnings, üî¥ for critical, üí° for suggestions, ‚úÖ for praise
          
          Focus on:
          - Security issues (SQL injection, XSS, hardcoded secrets)
          - Potential bugs and logic errors
          - Code quality and best practices
          - Performance concerns
          - Missing error handling
          
          Return ONLY valid JSON, no markdown code blocks.
          `;
          
          let result = '';
          for await (const message of execute({
            prompt,
            options: {
              dangerouslyAllowAll: true,
              cwd: process.cwd()
            }
          })) {
            if (message.type === 'result' && !message.is_error) {
              result = message.result;
            }
          }
          
          // Parse the JSON result
          try {
            // Clean up result - remove markdown code blocks if present
            let cleanResult = result.trim();
            if (cleanResult.startsWith('```json')) {
              cleanResult = cleanResult.replace(/^```json\n?/, '').replace(/\n?```$/, '');
            } else if (cleanResult.startsWith('```')) {
              cleanResult = cleanResult.replace(/^```\n?/, '').replace(/\n?```$/, '');
            }
            
            const reviewData = JSON.parse(cleanResult);
            writeFileSync('review-comments.json', JSON.stringify(reviewData, null, 2));
            console.log('Review generated with', reviewData.comments?.length || 0, 'inline comments');
          } catch (e) {
            console.error('Failed to parse review JSON:', e.message);
            // Fallback: save as summary only
            writeFileSync('review-comments.json', JSON.stringify({
              summary: result,
              decision: 'COMMENT',
              comments: []
            }));
          }
          EOF
          
          node amp-review.mjs 2>&1 || echo "Review completed"

      - name: Post inline review comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read the review data
            let reviewData = { summary: '', decision: 'COMMENT', comments: [] };
            if (fs.existsSync('review-comments.json')) {
              try {
                reviewData = JSON.parse(fs.readFileSync('review-comments.json', 'utf8'));
                console.log('Loaded review data:', JSON.stringify(reviewData, null, 2));
              } catch (e) {
                console.log('Could not parse review JSON:', e.message);
              }
            } else {
              console.log('review-comments.json not found');
            }
            
            // Get the list of files in this PR with their diff information
            const { data: prFiles } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            console.log('PR files:', prFiles.map(f => f.filename));
            
            // Build a map of valid paths and their changed line ranges
            const fileLineMap = new Map();
            for (const file of prFiles) {
              const addedLines = new Set();
              if (file.patch) {
                // Parse the patch to find added/modified line numbers
                const lines = file.patch.split('\n');
                let currentLine = 0;
                for (const line of lines) {
                  // Match @@ -start,count +start,count @@ format
                  const hunkMatch = line.match(/^@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@/);
                  if (hunkMatch) {
                    currentLine = parseInt(hunkMatch[1], 10);
                  } else if (line.startsWith('+') && !line.startsWith('+++')) {
                    addedLines.add(currentLine);
                    currentLine++;
                  } else if (line.startsWith('-') && !line.startsWith('---')) {
                    // Deleted line, don't increment currentLine
                  } else if (!line.startsWith('\\')) {
                    // Context line
                    currentLine++;
                  }
                }
              }
              fileLineMap.set(file.filename, addedLines);
            }
            
            // Filter comments to only include valid file paths AND lines in the diff
            const validComments = [];
            const skippedComments = [];
            
            for (const comment of (reviewData.comments || [])) {
              if (!fileLineMap.has(comment.path)) {
                skippedComments.push({ reason: 'invalid path', ...comment });
                continue;
              }
              if (!comment.line || comment.line < 1) {
                skippedComments.push({ reason: 'invalid line number', ...comment });
                continue;
              }
              
              const addedLines = fileLineMap.get(comment.path);
              if (addedLines.size === 0 || addedLines.has(comment.line)) {
                // Either we couldn't parse the patch, or the line is in the diff
                validComments.push(comment);
              } else {
                // Try to find the nearest valid line
                const sortedLines = Array.from(addedLines).sort((a, b) => a - b);
                const nearestLine = sortedLines.reduce((prev, curr) => 
                  Math.abs(curr - comment.line) < Math.abs(prev - comment.line) ? curr : prev
                , sortedLines[0]);
                
                if (nearestLine && Math.abs(nearestLine - comment.line) <= 10) {
                  // Use nearest line if within 10 lines
                  validComments.push({ ...comment, line: nearestLine, body: `${comment.body}\n\n*(Originally for line ${comment.line})*` });
                } else {
                  skippedComments.push({ reason: `line ${comment.line} not in diff`, ...comment });
                }
              }
            }
            
            console.log(`Valid comments: ${validComments.length}, Skipped: ${skippedComments.length}`);
            if (skippedComments.length > 0) {
              console.log('Skipped comments:', JSON.stringify(skippedComments, null, 2));
            }
            
            // Build the review summary
            let summaryBody = '## ü§ñ AMP AI Code Review\n\n';
            summaryBody += `### üìä Change Summary\n`;
            summaryBody += `- **Java Files Changed**: ${{ steps.changed-files.outputs.java_count }}\n`;
            summaryBody += `- **Test Files Changed**: ${{ steps.changed-files.outputs.test_count }}\n`;
            summaryBody += `- **Build Status**: ${{ steps.build-analyze.outputs.build_status == '0' && '‚úÖ Passed' || '‚ùå Failed' }}\n`;
            summaryBody += `- **Inline Comments**: ${validComments.length}\n\n`;
            
            if (reviewData.summary) {
              summaryBody += '### üîç Review Summary\n\n';
              summaryBody += reviewData.summary;
            }
            
            // Add skipped comments as a list in the summary
            if (skippedComments.length > 0) {
              summaryBody += '\n\n### üìù Additional Notes\n\n';
              summaryBody += 'The following comments could not be added inline:\n\n';
              for (const c of skippedComments.slice(0, 5)) {
                summaryBody += `- **${c.path}** (line ${c.line}): ${c.body.substring(0, 100)}${c.body.length > 100 ? '...' : ''}\n`;
              }
              if (skippedComments.length > 5) {
                summaryBody += `- ...and ${skippedComments.length - 5} more\n`;
              }
            }
            
            summaryBody += '\n\n---\n*Automated review by Sourcegraph AMP SDK*';
            
            // Map decision to GitHub review event
            const eventMap = {
              'APPROVE': 'APPROVE',
              'REQUEST_CHANGES': 'REQUEST_CHANGES',
              'COMMENT': 'COMMENT'
            };
            const event = eventMap[reviewData.decision] || 'COMMENT';
            
            // Create the review with inline comments
            if (validComments.length > 0) {
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  commit_id: context.payload.pull_request.head.sha,
                  body: summaryBody,
                  event: event,
                  comments: validComments.map(c => ({
                    path: c.path,
                    line: c.line,
                    side: 'RIGHT',
                    body: c.body
                  }))
                });
                console.log(`Created review with ${validComments.length} inline comments`);
              } catch (e) {
                console.log('Failed to create review with inline comments:', e.message);
                console.log('Error details:', JSON.stringify(e, null, 2));
                // Fallback: post as regular comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: summaryBody + '\n\n*Note: Inline comments failed to post. Error: ' + e.message + '*'
                });
              }
            } else {
              // No inline comments, just post summary
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: summaryBody
              });
            }

      - name: Log review action
        run: |
          echo "=== AMP PR Review Log ===" >> amp-review-log.txt
          echo "Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> amp-review-log.txt
          echo "PR Number: ${{ github.event.pull_request.number }}" >> amp-review-log.txt
          echo "PR Author: ${{ github.event.pull_request.user.login }}" >> amp-review-log.txt
          echo "Java Files: ${{ steps.changed-files.outputs.java_count }}" >> amp-review-log.txt
          echo "Test Files: ${{ steps.changed-files.outputs.test_count }}" >> amp-review-log.txt

      - name: Upload review artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: amp-review-logs
          path: |
            amp-review-log.txt
            review-comments.json
            *-log.txt
          retention-days: 30

  test-coverage-check:
    name: Test Coverage Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Run tests with coverage
        run: |
          mvn clean test jacoco:report -B 2>&1 || true

      - name: Check coverage thresholds
        id: coverage-check
        run: |
          COVERAGE=0
          if [ -f "target/site/jacoco/index.html" ]; then
            COVERAGE=$(grep -oP 'Total.*?([0-9]+)%' target/site/jacoco/index.html | grep -oP '[0-9]+' | head -1 || echo "0")
          fi
          
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
          
          if [ "$COVERAGE" -lt 60 ]; then
            echo "::warning::Test coverage is below 60%: ${COVERAGE}%"
          fi

      - name: Post coverage comment
        uses: actions/github-script@v7
        with:
          script: |
            const coverage = '${{ steps.coverage-check.outputs.coverage }}' || '0';
            const coverageNum = parseInt(coverage) || 0;
            const emoji = coverageNum >= 80 ? 'üü¢' : coverageNum >= 60 ? 'üü°' : 'üî¥';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `## ${emoji} Test Coverage Report\n\n**Coverage: ${coverage}%**\n\n${coverageNum < 60 ? '‚ö†Ô∏è Coverage is below the recommended threshold of 60%' : '‚úÖ Coverage meets the threshold'}`
            });

  guardrails-check:
    name: Guardrails Compliance
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check merge permissions
        run: |
          echo "::notice::AMP agents cannot merge PRs - human approval required"

      - name: Check restricted file modifications
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const restrictedPatterns = [
              /^\.github\/workflows\//,
              /secrets?\./i,
              /credentials?\./i,
              /\.env$/,
              /application-prod\.(yml|properties)$/
            ];
            
            const restrictedFiles = files.filter(f => 
              restrictedPatterns.some(p => p.test(f.filename))
            );
            
            if (restrictedFiles.length > 0) {
              const fileList = restrictedFiles.map(f => `- ${f.filename}`).join('\n');
              core.warning(`Restricted files modified:\n${fileList}`);
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `## ‚ö†Ô∏è Restricted Files Modified\n\nThe following sensitive files have been modified and require additional review:\n\n${fileList}\n\n**Action Required**: Security/Architecture team review needed.`
              });
            }
